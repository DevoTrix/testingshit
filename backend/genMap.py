from requests.auth import HTTPBasicAuth
import pandas as pd
from datetime import datetime
import matplotlib.pyplot as plt
import os
import dbMfunctions as dc
from dotenv import load_dotenv
load_dotenv()
import numpy as np
import io
from io import BytesIO
import base64
import folium
import webbrowser
import pandas as pd
from folium.plugins import HeatMap
from contentful_management import Client

###############################################################################################################
####                                            mapGeneration                                              ####
####        Map generation function to display all currently active monitors at the time of generation,    ####
####    complete with popups that display information including the monitor number, serial number, PM2.5   ####
####    & PM10 values, & timestamp. This is all then visualized in an HTML file generated by the function  ####
###############################################################################################################


def mapGeneration(data=None, pm_type='pm10'):
    if data is None:
        data = dc.getAllRecent()
    if(data.empty):
        return
    # Generate a map with a central location of the Salton Sea area
    central_latitude = data['geo.lat'].mean()
    central_longitude = data['geo.lon'].mean()
    m = folium.Map(location=[central_latitude, central_longitude], zoom_start=10,
                   tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                   attr='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://cartodb.com/attributions">CartoDB</a>')

    # Define air quality color ranges based on PM2.5 values
    color_ranges = {
        'pm10': {
            (0, 50): "green",
            (51, 100): "yellow",
            (101, 150): "orange",
            (151, 200): "red",
            (201, 300): "purple",
            (301, float('inf')): "maroon"
        },
        'pm25': {
            (0, 50): "green",
            (51, 100): "yellow",
            (101, 150): "orange",
            (151, 200): "red",
            (201, 300): "purple",
            (301, float('inf')): "maroon"
        }
    }

    selected_color_range = color_ranges.get(pm_type)
    # Add markers for each monitor with appropriate air quality color
    for index, row in data.dropna(subset=['geo.lat', 'geo.lon', pm_type]).iterrows():
        latitude = row['geo.lat']
        longitude = row['geo.lon']
        pm_value = row[pm_type]
        img = genTimeGraph(row['description'])
        # Determine the air quality color based on the PM2.5 value
        marker_color = "blue"  # Default color if value doesn't fall into any range
        for (min_value, max_value), color in selected_color_range.items():
            if min_value <= pm_value <= max_value:
                marker_color = color
                break



        folium.CircleMarker(
            location=[latitude, longitude],
            radius=5,
            color=marker_color,
            fill=True,
            fill_color=marker_color,
            fill_opacity=1,
            popup=f"""
                Serial Number: {row['sn']}<br>
                Latitude: {latitude}<br>
                Longitude: {longitude}<br>
                {pm_type.upper()}: {pm_value}<br>
                Timestamp: {row['timestamp']}<br>
                {img}
            """
        ).add_to(m)
        #border color is black now
        folium.CircleMarker(
        location=[latitude, longitude],
        radius=6,
        color="black",
        fill=False,
        ).add_to(m)


    # Adding Dropdown Menu
    dropdown_html = f"""
    <form action="/changePMType" method="post">
    <select id="pm_dropdown" name = pm_type>
        <option value="pm10" {'selected' if pm_type == 'pm10' else ''}>PM10</option>
        <option value="pm25" {'selected' if pm_type == 'pm25' else ''}>PM2.5</option>
    </select>
    <button type="submit">Change</button>
    </form>
    """

    m.get_root().html.add_child(folium.Element(dropdown_html))

    # Adding Legend
    legend_html = """
    <div style="position: fixed;
                bottom: 50px; right: 50px; width: 230px; height: 155px;
                border:3px solid black; z-index:9999; font-size:14px;
                background-color:#f2f2f2;
                /* Custom Ornate Border */
                border-image: url('path/to/ornate-border.png') 30 round;
                ">
    &nbsp;<b>Legend</b><br>
    &nbsp;<i class="dot" style="background: green;"></i>&nbsp;Good<br>
    &nbsp;<i class="dot" style="background: yellow;"></i>&nbsp;Moderate<br>
    &nbsp;<i class="dot" style="background: orange;"></i>&nbsp;Unhealthy for Sensitive Groups<br>
    &nbsp;<i class="dot" style="background: red;"></i>&nbsp;Unhealthy<br>
    &nbsp;<i class="dot" style="background: purple;"></i>&nbsp;Very Unhealthy<br>
    &nbsp;<i class="dot" style="background: maroon;"></i>&nbsp;Hazardous<br>
    </div>
    <style>
        .dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
    </style>
    """
    m.get_root().html.add_child(folium.Element(legend_html))
    
    # Save the map as an HTML file
    # html_file_path = 'views/map.hbs'
    # m.save(html_file_path)
    # print(m)
    client = Client(os.environ['ContentfulApiToken'])
    # print(type(m))
    html_content = m.get_root().render()
    entry_data = {
        'fields': {
            'testing': {
                'en-US': "t"
            },
            'htmlContent': {
                'en-US': {
                    'nodeType': 'document',
                    'data': {},  # Add required data attribute
                    'content': [
                        {
                            'nodeType': 'paragraph',
                            'data': {},  # Add required data attribute
                            'content': [
                                {
                                    'nodeType': 'text',
                                    'value':  html_content,
                                    'data':{},
                                    'marks':[]
                                }
                            ]
                        }
                    ]
                }
            }
        }
    }


    try:
        space_id = os.environ['ContentfulID']
        environment_id = os.environ['environmentID']
        content_type_id = 'n21o2'  # Replace 'n21o2' with the actual content type ID
        space = client.spaces().find(space_id)
        environment = space.environments().find(environment_id)
        entry_id = pm_type
        try:
            entry = client.entries(space_id, environment_id).find(entry_id)
            if(entry):
                print(entry)
                updated_entry = entry.update(entry_data)
                updated_entry.publish()
            else:
                entry = environment.content_types().find(content_type_id).entries().create(entry_id, entry_data)
                entry.publish()
        except Exception as e:
            print('Error creating entry:', e)
            entry = environment.content_types().find(content_type_id).entries().create(entry_id, entry_data)
            entry.publish()   
            
        # environment.close()
        # space.close()
        # client.close()
        # new_entry = space.entries().create(id, entry_data)
    except Exception as e:
        print('Error creating entry:', e)


def genTimeGraph(serialNumber):
    data = dc.pullDataTime(serialNumber, 30)
    # print(data.keys())
    plt.figure(figsize=(10, 6))
    if(data.empty):
        return

    # data = data.dropna(axis=0, how="any")
    data['timestamp'] = pd.to_datetime(data['timestamp'])

    # data.set_index('timestamp',inplace=True)
    plt.plot(data['timestamp'], data['pm25'], label = "pm2.5")
    plt.plot(data['timestamp'], data['pm10'], label = "pm10")
    plt.xticks(rotation=45, ha='right')
    plt.xlabel("time")
    plt.ylabel("PM Values")
    plt.legend()
    # temp_file_path = 'pmtimegraph_'+serialNumber+'.png'
    # plt.savefig(temp_file_path)
    # # file_pattern = 'pmtimegraph_*.png'

    # with open(temp_file_path, 'rb') as file:
    #     img_data = file.read()
    #     img_base64 = base64.b64encode(img_data).decode('utf-8')
    #     img_html = f'<img src="data:image/png;base64,{img_base64}" alt="PM2.5 Graph"style="width:400px; height:200px;">'
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    image_base64 = base64.b64encode(buf.getvalue()).decode('utf-8').replace('\n', '')
    buf.close()
    img_html = f'<img src="data:image/png;base64,{image_base64}" alt="PM2.5 Graph"style="width:400px; height:200px;">'
    plt.clf()
    plt.close()
    # os.remove(temp_file_path)
    return img_html